package clickhouseanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/LGU-SE-Internal/chaos-experiment/internal/systemconfig"
)

// ServiceEndpoints holds the service endpoints for a service
type ServiceEndpoints struct {
	ServiceName string
	Endpoints   []ServiceEndpoint
}

// DatabaseOperations holds the database operations for a service
type DatabaseOperationsByService struct {
	ServiceName string
	Operations  []DatabaseOperation
}

// GRPCOperationsByService holds the gRPC operations for a service
type GRPCOperationsByService struct {
	ServiceName string
	Operations  []GRPCOperation
}

// Template for generating the Go file
const serviceEndpointsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

import (
	"github.com/LGU-SE-Internal/chaos-experiment/internal/resourcetypes"
)

// ServiceEndpoint is an alias for the shared type
type ServiceEndpoint = resourcetypes.ServiceEndpoint

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Endpoints }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RequestMethod:  "{{ .RequestMethod }}",
			ResponseStatus: "{{ .ResponseStatus }}",
			Route:          "{{ .Route }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
			SpanName:       "{{ .SpanName }}",
		},
		{{- end }}
	},
{{- end }}
}

// AllServices contains all unique service names (callers and callees)
var AllServices = []string{
{{- range .AllServices }}
	"{{ . }}",
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
	if endpoints, exists := ServiceEndpoints[serviceName]; exists {
		return endpoints
	}
	return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	return AllServices
}
`

// Template for generating the database operations Go file
const databaseOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

import (
	"github.com/LGU-SE-Internal/chaos-experiment/internal/resourcetypes"
)

// DatabaseOperation is an alias for the shared type
type DatabaseOperation = resourcetypes.DatabaseOperation

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:   "{{ .ServiceName }}",
			DBName:        "{{ .DBName }}",
			DBTable:       "{{ .DBTable }}",
			Operation:     "{{ .Operation }}",
			DBSystem:      "{{ .DBSystem }}",
			ServerAddress: "{{ .ServerAddress }}",
			ServerPort:    "{{ .ServerPort }}",
			SpanName:      "{{ .SpanName }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
	if operations, exists := DatabaseOperations[serviceName]; exists {
		return operations
	}
	return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
	services := make([]string, 0, len(DatabaseOperations))
	for service := range DatabaseOperations {
		services = append(services, service)
	}
	return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBName == dbName {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBTable == dbTable {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByDBSystem returns all operations for a specific database system
func GetOperationsByDBSystem(dbSystem string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBSystem == dbSystem {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// Template for generating the gRPC operations Go file
const grpcOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

import (
	"github.com/LGU-SE-Internal/chaos-experiment/internal/resourcetypes"
)

// GRPCOperation is an alias for the shared type
type GRPCOperation = resourcetypes.GRPCOperation

// GRPCOperations maps service names to their gRPC operations
var GRPCOperations = map[string][]GRPCOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RPCSystem:      "{{ .RPCSystem }}",
			RPCService:     "{{ .RPCService }}",
			RPCMethod:      "{{ .RPCMethod }}",
			StatusCode:     "{{ .StatusCode }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
			SpanKind:       "{{ .SpanKind }}",
			SpanName:       "{{ .SpanName }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all gRPC operations for a service
func GetOperationsByService(serviceName string) []GRPCOperation {
	if operations, exists := GRPCOperations[serviceName]; exists {
		return operations
	}
	return []GRPCOperation{}
}

// GetAllGRPCServices returns a list of all services that perform gRPC operations
func GetAllGRPCServices() []string {
	services := make([]string, 0, len(GRPCOperations))
	for service := range GRPCOperations {
		services = append(services, service)
	}
	return services
}

// GetClientOperations returns all client-side gRPC operations
func GetClientOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Client" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetServerOperations returns all server-side gRPC operations
func GetServerOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Server" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByRPCService returns all operations for a specific RPC service
func GetOperationsByRPCService(rpcService string) []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.RPCService == rpcService {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// getPackageNameFromPath extracts the package name from the output file path.
// It uses the directory name as the package name.
func getPackageNameFromPath(outputFilePath string) string {
	dir := filepath.Dir(outputFilePath)
	packageName := filepath.Base(dir)
	// Sanitize package name (replace - with _ for valid Go package names)
	packageName = strings.ReplaceAll(packageName, "-", "_")
	return packageName
}

// GenerateServiceEndpointsFile generates a Go file with service endpoints
func GenerateServiceEndpointsFile(endpoints []ServiceEndpoint, outputFilePath string) error {
	// Group endpoints by service
	serviceMap := make(map[string][]ServiceEndpoint)
	for _, endpoint := range endpoints {
		serviceMap[endpoint.ServiceName] = append(serviceMap[endpoint.ServiceName], endpoint)
	}

	// Transform to services slice
	var services []ServiceEndpoints
	for serviceName, serviceEndpoints := range serviceMap {
		services = append(services, ServiceEndpoints{
			ServiceName: serviceName,
			Endpoints:   serviceEndpoints,
		})
	}

	// Collect all unique services (both callers and callees)
	allServicesMap := make(map[string]bool)
	for _, endpoint := range endpoints {
		// Add the caller service
		if endpoint.ServiceName != "" {
			allServicesMap[endpoint.ServiceName] = true
		}
		// Add the callee service (ServerAddress)
		if endpoint.ServerAddress != "" {
			allServicesMap[endpoint.ServerAddress] = true
		}
	}

	// Convert to sorted slice
	var allServices []string
	for service := range allServicesMap {
		allServices = append(allServices, service)
	}
	sort.Strings(allServices)

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []ServiceEndpoints
		AllServices []string
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
		AllServices: allServices,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("serviceEndpointsTemplate").Parse(serviceEndpointsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateDatabaseOperationsFile generates a Go file with database operations
func GenerateDatabaseOperationsFile(operations []DatabaseOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]DatabaseOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []DatabaseOperationsByService
	for serviceName, dbOperations := range serviceMap {
		services = append(services, DatabaseOperationsByService{
			ServiceName: serviceName,
			Operations:  dbOperations,
		})
	}

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []DatabaseOperationsByService
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("databaseOperationsTemplate").Parse(databaseOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateGRPCOperationsFile generates a Go file with gRPC operations
func GenerateGRPCOperationsFile(operations []GRPCOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]GRPCOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []GRPCOperationsByService
	for serviceName, grpcOperations := range serviceMap {
		services = append(services, GRPCOperationsByService{
			ServiceName: serviceName,
			Operations:  grpcOperations,
		})
	}

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []GRPCOperationsByService
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("grpcOperationsTemplate").Parse(grpcOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
