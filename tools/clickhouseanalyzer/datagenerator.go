package clickhouseanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// ServiceEndpoints holds the service endpoints for a service
type ServiceEndpoints struct {
	ServiceName string
	Endpoints   []ServiceEndpoint
}

// DatabaseOperations holds the database operations for a service
type DatabaseOperationsByService struct {
	ServiceName string
	Operations  []DatabaseOperation
}

// Template for generating the Go file
const serviceEndpointsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package serviceendpoints

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
	ServiceName      string
	RequestMethod    string
	ResponseStatus   string
	Route            string
	ServerAddress    string
	ServerPort       string
}

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Endpoints }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RequestMethod:  "{{ .RequestMethod }}",
			ResponseStatus: "{{ .ResponseStatus }}",
			Route:          "{{ .Route }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
	if endpoints, exists := ServiceEndpoints[serviceName]; exists {
		return endpoints
	}
	return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	services := make([]string, 0, len(ServiceEndpoints))
	for service := range ServiceEndpoints {
		services = append(services, service)
	}
	return services
}
`

// Template for generating the database operations Go file
const databaseOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package databaseoperations

// DatabaseOperation represents a database operation from ClickHouse analysis
type DatabaseOperation struct {
	ServiceName string
	DBName      string
	DBTable     string
	Operation   string
}

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName: "{{ .ServiceName }}",
			DBName:      "{{ .DBName }}",
			DBTable:     "{{ .DBTable }}",
			Operation:   "{{ .Operation }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
	if operations, exists := DatabaseOperations[serviceName]; exists {
		return operations
	}
	return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
	services := make([]string, 0, len(DatabaseOperations))
	for service := range DatabaseOperations {
		services = append(services, service)
	}
	return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBName == dbName {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBTable == dbTable {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// GenerateServiceEndpointsFile generates a Go file with service endpoints
func GenerateServiceEndpointsFile(endpoints []ServiceEndpoint, outputFilePath string) error {
	// Group endpoints by service
	serviceMap := make(map[string][]ServiceEndpoint)
	for _, endpoint := range endpoints {
		serviceMap[endpoint.ServiceName] = append(serviceMap[endpoint.ServiceName], endpoint)
	}

	// Transform to services slice
	var services []ServiceEndpoints
	for serviceName, serviceEndpoints := range serviceMap {
		services = append(services, ServiceEndpoints{
			ServiceName: serviceName,
			Endpoints:   serviceEndpoints,
		})
	}

	// Create template data
	templateData := struct {
		Services []ServiceEndpoints
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("serviceEndpointsTemplate").Parse(serviceEndpointsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateDatabaseOperationsFile generates a Go file with database operations
func GenerateDatabaseOperationsFile(operations []DatabaseOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]DatabaseOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []DatabaseOperationsByService
	for serviceName, dbOperations := range serviceMap {
		services = append(services, DatabaseOperationsByService{
			ServiceName: serviceName,
			Operations:  dbOperations,
		})
	}

	// Create template data
	templateData := struct {
		Services []DatabaseOperationsByService
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("databaseOperationsTemplate").Parse(databaseOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
