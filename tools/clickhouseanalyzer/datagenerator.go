package clickhouseanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// ServiceEndpoints holds the service endpoints for a service
type ServiceEndpoints struct {
	ServiceName string
	Endpoints   []ServiceEndpoint
}

// DatabaseOperations holds the database operations for a service
type DatabaseOperationsByService struct {
	ServiceName string
	Operations  []DatabaseOperation
}

// GRPCOperationsByService holds the gRPC operations for a service
type GRPCOperationsByService struct {
	ServiceName string
	Operations  []GRPCOperation
}

// Template for generating the Go file
const serviceEndpointsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package serviceendpoints

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
	ServiceName      string
	RequestMethod    string
	ResponseStatus   string
	Route            string
	ServerAddress    string
	ServerPort       string
}

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Endpoints }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RequestMethod:  "{{ .RequestMethod }}",
			ResponseStatus: "{{ .ResponseStatus }}",
			Route:          "{{ .Route }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
	if endpoints, exists := ServiceEndpoints[serviceName]; exists {
		return endpoints
	}
	return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	services := make([]string, 0, len(ServiceEndpoints))
	for service := range ServiceEndpoints {
		services = append(services, service)
	}
	return services
}
`

// Template for generating the database operations Go file
const databaseOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package databaseoperations

// DatabaseOperation represents a database operation from ClickHouse analysis
type DatabaseOperation struct {
	ServiceName   string
	DBName        string
	DBTable       string
	Operation     string
	DBSystem      string
	ServerAddress string
	ServerPort    string
}

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:   "{{ .ServiceName }}",
			DBName:        "{{ .DBName }}",
			DBTable:       "{{ .DBTable }}",
			Operation:     "{{ .Operation }}",
			DBSystem:      "{{ .DBSystem }}",
			ServerAddress: "{{ .ServerAddress }}",
			ServerPort:    "{{ .ServerPort }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
	if operations, exists := DatabaseOperations[serviceName]; exists {
		return operations
	}
	return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
	services := make([]string, 0, len(DatabaseOperations))
	for service := range DatabaseOperations {
		services = append(services, service)
	}
	return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBName == dbName {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBTable == dbTable {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByDBSystem returns all operations for a specific database system
func GetOperationsByDBSystem(dbSystem string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBSystem == dbSystem {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// Template for generating the gRPC operations Go file
const grpcOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package grpcoperations

// GRPCOperation represents a gRPC operation from ClickHouse analysis
type GRPCOperation struct {
	ServiceName    string
	RPCSystem      string
	RPCService     string
	RPCMethod      string
	GRPCStatusCode string
	ServerAddress  string
	ServerPort     string
	SpanKind       string
}

// GRPCOperations maps service names to their gRPC operations
var GRPCOperations = map[string][]GRPCOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RPCSystem:      "{{ .RPCSystem }}",
			RPCService:     "{{ .RPCService }}",
			RPCMethod:      "{{ .RPCMethod }}",
			GRPCStatusCode: "{{ .GRPCStatusCode }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
			SpanKind:       "{{ .SpanKind }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all gRPC operations for a service
func GetOperationsByService(serviceName string) []GRPCOperation {
	if operations, exists := GRPCOperations[serviceName]; exists {
		return operations
	}
	return []GRPCOperation{}
}

// GetAllGRPCServices returns a list of all services that perform gRPC operations
func GetAllGRPCServices() []string {
	services := make([]string, 0, len(GRPCOperations))
	for service := range GRPCOperations {
		services = append(services, service)
	}
	return services
}

// GetClientOperations returns all client-side gRPC operations
func GetClientOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Client" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetServerOperations returns all server-side gRPC operations
func GetServerOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Server" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByRPCService returns all operations for a specific RPC service
func GetOperationsByRPCService(rpcService string) []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.RPCService == rpcService {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// GenerateServiceEndpointsFile generates a Go file with service endpoints
func GenerateServiceEndpointsFile(endpoints []ServiceEndpoint, outputFilePath string) error {
	// Group endpoints by service
	serviceMap := make(map[string][]ServiceEndpoint)
	for _, endpoint := range endpoints {
		serviceMap[endpoint.ServiceName] = append(serviceMap[endpoint.ServiceName], endpoint)
	}

	// Transform to services slice
	var services []ServiceEndpoints
	for serviceName, serviceEndpoints := range serviceMap {
		services = append(services, ServiceEndpoints{
			ServiceName: serviceName,
			Endpoints:   serviceEndpoints,
		})
	}

	// Create template data
	templateData := struct {
		Services []ServiceEndpoints
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("serviceEndpointsTemplate").Parse(serviceEndpointsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateDatabaseOperationsFile generates a Go file with database operations
func GenerateDatabaseOperationsFile(operations []DatabaseOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]DatabaseOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []DatabaseOperationsByService
	for serviceName, dbOperations := range serviceMap {
		services = append(services, DatabaseOperationsByService{
			ServiceName: serviceName,
			Operations:  dbOperations,
		})
	}

	// Create template data
	templateData := struct {
		Services []DatabaseOperationsByService
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("databaseOperationsTemplate").Parse(databaseOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateGRPCOperationsFile generates a Go file with gRPC operations
func GenerateGRPCOperationsFile(operations []GRPCOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]GRPCOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []GRPCOperationsByService
	for serviceName, grpcOperations := range serviceMap {
		services = append(services, GRPCOperationsByService{
			ServiceName: serviceName,
			Operations:  grpcOperations,
		})
	}

	// Create template data
	templateData := struct {
		Services []GRPCOperationsByService
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("grpcOperationsTemplate").Parse(grpcOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
