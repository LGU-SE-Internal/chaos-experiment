package clickhouseanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/LGU-SE-Internal/chaos-experiment/internal/systemconfig"
)

// ServiceEndpoints holds the service endpoints for a service
type ServiceEndpoints struct {
	ServiceName string
	Endpoints   []ServiceEndpoint
}

// DatabaseOperations holds the database operations for a service
type DatabaseOperationsByService struct {
	ServiceName string
	Operations  []DatabaseOperation
}

// GRPCOperationsByService holds the gRPC operations for a service
type GRPCOperationsByService struct {
	ServiceName string
	Operations  []GRPCOperation
}

// Template for generating the Go file
const serviceEndpointsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
	ServiceName      string
	RequestMethod    string
	ResponseStatus   string
	Route            string
	ServerAddress    string
	ServerPort       string
	SpanName         string
}

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Endpoints }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RequestMethod:  "{{ .RequestMethod }}",
			ResponseStatus: "{{ .ResponseStatus }}",
			Route:          "{{ .Route }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
			SpanName:       "{{ .SpanName }}",
		},
		{{- end }}
	},
{{- end }}
}

// AllServices contains all unique service names (callers and callees)
var AllServices = []string{
{{- range .AllServices }}
	"{{ . }}",
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
	if endpoints, exists := ServiceEndpoints[serviceName]; exists {
		return endpoints
	}
	return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	return AllServices
}
`

// Template for generating the database operations Go file
const databaseOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

// DatabaseOperation represents a database operation from ClickHouse analysis
type DatabaseOperation struct {
	ServiceName   string
	DBName        string
	DBTable       string
	Operation     string
	DBSystem      string
	ServerAddress string
	ServerPort    string
}

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:   "{{ .ServiceName }}",
			DBName:        "{{ .DBName }}",
			DBTable:       "{{ .DBTable }}",
			Operation:     "{{ .Operation }}",
			DBSystem:      "{{ .DBSystem }}",
			ServerAddress: "{{ .ServerAddress }}",
			ServerPort:    "{{ .ServerPort }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
	if operations, exists := DatabaseOperations[serviceName]; exists {
		return operations
	}
	return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
	services := make([]string, 0, len(DatabaseOperations))
	for service := range DatabaseOperations {
		services = append(services, service)
	}
	return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBName == dbName {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBTable == dbTable {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByDBSystem returns all operations for a specific database system
func GetOperationsByDBSystem(dbSystem string) []DatabaseOperation {
	var results []DatabaseOperation
	for _, operations := range DatabaseOperations {
		for _, op := range operations {
			if op.DBSystem == dbSystem {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// Template for generating the gRPC operations Go file
const grpcOperationsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

// GRPCOperation represents a gRPC operation from ClickHouse analysis
type GRPCOperation struct {
	ServiceName    string
	RPCSystem      string
	RPCService     string
	RPCMethod      string
	GRPCStatusCode string
	ServerAddress  string
	ServerPort     string
	SpanKind       string
}

// GRPCOperations maps service names to their gRPC operations
var GRPCOperations = map[string][]GRPCOperation{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Operations }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RPCSystem:      "{{ .RPCSystem }}",
			RPCService:     "{{ .RPCService }}",
			RPCMethod:      "{{ .RPCMethod }}",
			GRPCStatusCode: "{{ .GRPCStatusCode }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
			SpanKind:       "{{ .SpanKind }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetOperationsByService returns all gRPC operations for a service
func GetOperationsByService(serviceName string) []GRPCOperation {
	if operations, exists := GRPCOperations[serviceName]; exists {
		return operations
	}
	return []GRPCOperation{}
}

// GetAllGRPCServices returns a list of all services that perform gRPC operations
func GetAllGRPCServices() []string {
	services := make([]string, 0, len(GRPCOperations))
	for service := range GRPCOperations {
		services = append(services, service)
	}
	return services
}

// GetClientOperations returns all client-side gRPC operations
func GetClientOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Client" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetServerOperations returns all server-side gRPC operations
func GetServerOperations() []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.SpanKind == "Server" {
				results = append(results, op)
			}
		}
	}
	return results
}

// GetOperationsByRPCService returns all operations for a specific RPC service
func GetOperationsByRPCService(rpcService string) []GRPCOperation {
	var results []GRPCOperation
	for _, operations := range GRPCOperations {
		for _, op := range operations {
			if op.RPCService == rpcService {
				results = append(results, op)
			}
		}
	}
	return results
}
`

// getPackageNameFromPath extracts the package name from the output file path.
// It uses the directory name as the package name.
func getPackageNameFromPath(outputFilePath string) string {
	dir := filepath.Dir(outputFilePath)
	packageName := filepath.Base(dir)
	// Sanitize package name (replace - with _ for valid Go package names)
	packageName = strings.ReplaceAll(packageName, "-", "_")
	return packageName
}

// GenerateServiceEndpointsFile generates a Go file with service endpoints
func GenerateServiceEndpointsFile(endpoints []ServiceEndpoint, outputFilePath string) error {
	// Group endpoints by service
	serviceMap := make(map[string][]ServiceEndpoint)
	for _, endpoint := range endpoints {
		serviceMap[endpoint.ServiceName] = append(serviceMap[endpoint.ServiceName], endpoint)
	}

	// Transform to services slice
	var services []ServiceEndpoints
	for serviceName, serviceEndpoints := range serviceMap {
		services = append(services, ServiceEndpoints{
			ServiceName: serviceName,
			Endpoints:   serviceEndpoints,
		})
	}

	// Collect all unique services (both callers and callees)
	allServicesMap := make(map[string]bool)
	for _, endpoint := range endpoints {
		// Add the caller service
		if endpoint.ServiceName != "" {
			allServicesMap[endpoint.ServiceName] = true
		}
		// Add the callee service (ServerAddress)
		if endpoint.ServerAddress != "" {
			allServicesMap[endpoint.ServerAddress] = true
		}
	}

	// Convert to sorted slice
	var allServices []string
	for service := range allServicesMap {
		allServices = append(allServices, service)
	}
	sort.Strings(allServices)

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []ServiceEndpoints
		AllServices []string
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
		AllServices: allServices,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("serviceEndpointsTemplate").Parse(serviceEndpointsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateDatabaseOperationsFile generates a Go file with database operations
func GenerateDatabaseOperationsFile(operations []DatabaseOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]DatabaseOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []DatabaseOperationsByService
	for serviceName, dbOperations := range serviceMap {
		services = append(services, DatabaseOperationsByService{
			ServiceName: serviceName,
			Operations:  dbOperations,
		})
	}

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []DatabaseOperationsByService
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("databaseOperationsTemplate").Parse(databaseOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// GenerateGRPCOperationsFile generates a Go file with gRPC operations
func GenerateGRPCOperationsFile(operations []GRPCOperation, outputFilePath string) error {
	// Group operations by service
	serviceMap := make(map[string][]GRPCOperation)
	for _, operation := range operations {
		serviceMap[operation.ServiceName] = append(serviceMap[operation.ServiceName], operation)
	}

	// Transform to services slice
	var services []GRPCOperationsByService
	for serviceName, grpcOperations := range serviceMap {
		services = append(services, GRPCOperationsByService{
			ServiceName: serviceName,
			Operations:  grpcOperations,
		})
	}

	// Get package name from the output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []GRPCOperationsByService
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("grpcOperationsTemplate").Parse(grpcOperationsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// Template for generating a unified resources Go file with all resource types
const unifiedResourcesTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package resources

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
ServiceName      string
RequestMethod    string
ResponseStatus   string
Route            string
ServerAddress    string
ServerPort       string
SpanName         string
}

// DatabaseOperation represents a database operation from ClickHouse analysis
type DatabaseOperation struct {
ServiceName   string
DBName        string
DBTable       string
Operation     string
DBSystem      string
ServerAddress string
ServerPort    string
}

// GRPCOperation represents a gRPC operation from ClickHouse analysis
type GRPCOperation struct {
ServiceName    string
RPCSystem      string
RPCService     string
RPCMethod      string
GRPCStatusCode string
ServerAddress  string
ServerPort     string
SpanKind       string
}

// ========================================
// Service Endpoints Data
// ========================================

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .EndpointServices }}
"{{ .ServiceName }}": {
{{- range .Endpoints }}
{
ServiceName:    "{{ .ServiceName }}",
RequestMethod:  "{{ .RequestMethod }}",
ResponseStatus: "{{ .ResponseStatus }}",
Route:          "{{ .Route }}",
ServerAddress:  "{{ .ServerAddress }}",
ServerPort:     "{{ .ServerPort }}",
SpanName:       "{{ .SpanName }}",
},
{{- end }}
},
{{- end }}
}

// AllServices contains all unique service names (callers and callees)
var AllServices = []string{
{{- range .AllServices }}
"{{ . }}",
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
if endpoints, exists := ServiceEndpoints[serviceName]; exists {
return endpoints
}
return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
return AllServices
}

// ========================================
// Database Operations Data
// ========================================

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .DBServices }}
"{{ .ServiceName }}": {
{{- range .Operations }}
{
ServiceName:   "{{ .ServiceName }}",
DBName:        "{{ .DBName }}",
DBTable:       "{{ .DBTable }}",
Operation:     "{{ .Operation }}",
DBSystem:      "{{ .DBSystem }}",
ServerAddress: "{{ .ServerAddress }}",
ServerPort:    "{{ .ServerPort }}",
},
{{- end }}
},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
if operations, exists := DatabaseOperations[serviceName]; exists {
return operations
}
return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
services := make([]string, 0, len(DatabaseOperations))
for service := range DatabaseOperations {
services = append(services, service)
}
return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBName == dbName {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBTable == dbTable {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByDBSystem returns all operations for a specific database system
func GetOperationsByDBSystem(dbSystem string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBSystem == dbSystem {
results = append(results, op)
}
}
}
return results
}

// ========================================
// gRPC Operations Data
// ========================================

// GRPCOperations maps service names to their gRPC operations
var GRPCOperations = map[string][]GRPCOperation{
{{- range .GRPCServices }}
"{{ .ServiceName }}": {
{{- range .Operations }}
{
ServiceName:    "{{ .ServiceName }}",
RPCSystem:      "{{ .RPCSystem }}",
RPCService:     "{{ .RPCService }}",
RPCMethod:      "{{ .RPCMethod }}",
GRPCStatusCode: "{{ .GRPCStatusCode }}",
ServerAddress:  "{{ .ServerAddress }}",
ServerPort:     "{{ .ServerPort }}",
SpanKind:       "{{ .SpanKind }}",
},
{{- end }}
},
{{- end }}
}

// GetGRPCOperationsByService returns all gRPC operations for a service
func GetGRPCOperationsByService(serviceName string) []GRPCOperation {
if operations, exists := GRPCOperations[serviceName]; exists {
return operations
}
return []GRPCOperation{}
}

// GetAllGRPCServices returns a list of all services that perform gRPC operations
func GetAllGRPCServices() []string {
services := make([]string, 0, len(GRPCOperations))
for service := range GRPCOperations {
services = append(services, service)
}
return services
}

// GetClientOperations returns all client-side gRPC operations
func GetClientOperations() []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.SpanKind == "Client" {
results = append(results, op)
}
}
}
return results
}

// GetServerOperations returns all server-side gRPC operations
func GetServerOperations() []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.SpanKind == "Server" {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByRPCService returns all operations for a specific RPC service
func GetOperationsByRPCService(rpcService string) []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.RPCService == rpcService {
results = append(results, op)
}
}
}
return results
}

// IsGRPCRoutePattern checks if a route looks like a gRPC route (e.g., /package.Service/Method)
func IsGRPCRoutePattern(route string) bool {
// gRPC routes typically have the format: /package.Service/Method
// They contain a dot before the first slash
parts := strings.SplitN(route, "/", 3)
if len(parts) >= 2 && strings.Contains(parts[1], ".") {
return true
}
return false
}
`

// GenerateUnifiedResourcesFile generates a single Go file with all resource types
func GenerateUnifiedResourcesFile(endpoints []ServiceEndpoint, dbOperations []DatabaseOperation, grpcOperations []GRPCOperation, outputFilePath string) error {
// Group endpoints by service
endpointServiceMap := make(map[string][]ServiceEndpoint)
for _, endpoint := range endpoints {
endpointServiceMap[endpoint.ServiceName] = append(endpointServiceMap[endpoint.ServiceName], endpoint)
}

var endpointServices []ServiceEndpoints
for serviceName, serviceEndpoints := range endpointServiceMap {
endpointServices = append(endpointServices, ServiceEndpoints{
ServiceName: serviceName,
Endpoints:   serviceEndpoints,
})
}

// Collect all unique services
allServicesMap := make(map[string]bool)
for _, endpoint := range endpoints {
if endpoint.ServiceName != "" {
allServicesMap[endpoint.ServiceName] = true
}
if endpoint.ServerAddress != "" {
allServicesMap[endpoint.ServerAddress] = true
}
}

var allServices []string
for service := range allServicesMap {
allServices = append(allServices, service)
}
sort.Strings(allServices)

// Group database operations by service
dbServiceMap := make(map[string][]DatabaseOperation)
for _, operation := range dbOperations {
dbServiceMap[operation.ServiceName] = append(dbServiceMap[operation.ServiceName], operation)
}

var dbServices []DatabaseOperationsByService
for serviceName, operations := range dbServiceMap {
dbServices = append(dbServices, DatabaseOperationsByService{
ServiceName: serviceName,
Operations:  operations,
})
}

// Group gRPC operations by service
grpcServiceMap := make(map[string][]GRPCOperation)
for _, operation := range grpcOperations {
grpcServiceMap[operation.ServiceName] = append(grpcServiceMap[operation.ServiceName], operation)
}

var grpcServices []GRPCOperationsByService
for serviceName, operations := range grpcServiceMap {
grpcServices = append(grpcServices, GRPCOperationsByService{
ServiceName: serviceName,
Operations:  operations,
})
}

// Create template data
templateData := struct {
SystemType       string
EndpointServices []ServiceEndpoints
AllServices      []string
DBServices       []DatabaseOperationsByService
GRPCServices     []GRPCOperationsByService
}{
SystemType:       string(systemconfig.GetCurrentSystem()),
EndpointServices: endpointServices,
AllServices:      allServices,
DBServices:       dbServices,
GRPCServices:     grpcServices,
}

// Ensure output directory exists
outputDir := filepath.Dir(outputFilePath)
if err := os.MkdirAll(outputDir, 0755); err != nil {
return fmt.Errorf("failed to create output directory: %w", err)
}

// Parse template
tmpl, err := template.New("unifiedResourcesTemplate").Parse(unifiedResourcesTemplate)
if err != nil {
return fmt.Errorf("failed to parse template: %w", err)
}

// Create output file
outFile, err := os.Create(outputFilePath)
if err != nil {
return fmt.Errorf("failed to create output file: %w", err)
}
defer outFile.Close()

// Execute template
if err := tmpl.Execute(outFile, templateData); err != nil {
return fmt.Errorf("failed to execute template: %w", err)
}

return nil
}

// Template for generating a unified resources Go file with all resource types
const unifiedResourcesTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
// System: {{ .SystemType }}
package resources

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
ServiceName      string
RequestMethod    string
ResponseStatus   string
Route            string
ServerAddress    string
ServerPort       string
SpanName         string
}

// DatabaseOperation represents a database operation from ClickHouse analysis
type DatabaseOperation struct {
ServiceName   string
DBName        string
DBTable       string
Operation     string
DBSystem      string
ServerAddress string
ServerPort    string
}

// GRPCOperation represents a gRPC operation from ClickHouse analysis
type GRPCOperation struct {
ServiceName    string
RPCSystem      string
RPCService     string
RPCMethod      string
GRPCStatusCode string
ServerAddress  string
ServerPort     string
SpanKind       string
}

// ========================================
// Service Endpoints Data
// ========================================

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .EndpointServices }}
"{{ .ServiceName }}": {
{{- range .Endpoints }}
{
ServiceName:    "{{ .ServiceName }}",
RequestMethod:  "{{ .RequestMethod }}",
ResponseStatus: "{{ .ResponseStatus }}",
Route:          "{{ .Route }}",
ServerAddress:  "{{ .ServerAddress }}",
ServerPort:     "{{ .ServerPort }}",
SpanName:       "{{ .SpanName }}",
},
{{- end }}
},
{{- end }}
}

// AllServices contains all unique service names (callers and callees)
var AllServices = []string{
{{- range .AllServices }}
"{{ . }}",
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
if endpoints, exists := ServiceEndpoints[serviceName]; exists {
return endpoints
}
return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
return AllServices
}

// ========================================
// Database Operations Data
// ========================================

// DatabaseOperations maps service names to their database operations
var DatabaseOperations = map[string][]DatabaseOperation{
{{- range .DBServices }}
"{{ .ServiceName }}": {
{{- range .Operations }}
{
ServiceName:   "{{ .ServiceName }}",
DBName:        "{{ .DBName }}",
DBTable:       "{{ .DBTable }}",
Operation:     "{{ .Operation }}",
DBSystem:      "{{ .DBSystem }}",
ServerAddress: "{{ .ServerAddress }}",
ServerPort:    "{{ .ServerPort }}",
},
{{- end }}
},
{{- end }}
}

// GetOperationsByService returns all database operations for a service
func GetOperationsByService(serviceName string) []DatabaseOperation {
if operations, exists := DatabaseOperations[serviceName]; exists {
return operations
}
return []DatabaseOperation{}
}

// GetAllDatabaseServices returns a list of all services that perform database operations
func GetAllDatabaseServices() []string {
services := make([]string, 0, len(DatabaseOperations))
for service := range DatabaseOperations {
services = append(services, service)
}
return services
}

// GetOperationsByDatabase returns all operations for a specific database
func GetOperationsByDatabase(dbName string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBName == dbName {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByTable returns all operations for a specific table
func GetOperationsByTable(dbTable string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBTable == dbTable {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByDBSystem returns all operations for a specific database system
func GetOperationsByDBSystem(dbSystem string) []DatabaseOperation {
var results []DatabaseOperation
for _, operations := range DatabaseOperations {
for _, op := range operations {
if op.DBSystem == dbSystem {
results = append(results, op)
}
}
}
return results
}

// ========================================
// gRPC Operations Data
// ========================================

// GRPCOperations maps service names to their gRPC operations
var GRPCOperations = map[string][]GRPCOperation{
{{- range .GRPCServices }}
"{{ .ServiceName }}": {
{{- range .Operations }}
{
ServiceName:    "{{ .ServiceName }}",
RPCSystem:      "{{ .RPCSystem }}",
RPCService:     "{{ .RPCService }}",
RPCMethod:      "{{ .RPCMethod }}",
GRPCStatusCode: "{{ .GRPCStatusCode }}",
ServerAddress:  "{{ .ServerAddress }}",
ServerPort:     "{{ .ServerPort }}",
SpanKind:       "{{ .SpanKind }}",
},
{{- end }}
},
{{- end }}
}

// GetGRPCOperationsByService returns all gRPC operations for a service
func GetGRPCOperationsByService(serviceName string) []GRPCOperation {
if operations, exists := GRPCOperations[serviceName]; exists {
return operations
}
return []GRPCOperation{}
}

// GetAllGRPCServices returns a list of all services that perform gRPC operations
func GetAllGRPCServices() []string {
services := make([]string, 0, len(GRPCOperations))
for service := range GRPCOperations {
services = append(services, service)
}
return services
}

// GetClientOperations returns all client-side gRPC operations
func GetClientOperations() []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.SpanKind == "Client" {
results = append(results, op)
}
}
}
return results
}

// GetServerOperations returns all server-side gRPC operations
func GetServerOperations() []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.SpanKind == "Server" {
results = append(results, op)
}
}
}
return results
}

// GetOperationsByRPCService returns all operations for a specific RPC service
func GetOperationsByRPCService(rpcService string) []GRPCOperation {
var results []GRPCOperation
for _, operations := range GRPCOperations {
for _, op := range operations {
if op.RPCService == rpcService {
results = append(results, op)
}
}
}
return results
}

// IsGRPCRoutePattern checks if a route looks like a gRPC route (e.g., /package.Service/Method)
func IsGRPCRoutePattern(route string) bool {
// gRPC routes typically have the format: /package.Service/Method
// They contain a dot before the first slash
parts := strings.SplitN(route, "/", 3)
if len(parts) >= 2 && strings.Contains(parts[1], ".") {
return true
}
return false
}
`

// GenerateUnifiedResourcesFile generates a single Go file with all resource types
func GenerateUnifiedResourcesFile(endpoints []ServiceEndpoint, dbOperations []DatabaseOperation, grpcOperations []GRPCOperation, outputFilePath string) error {
// Group endpoints by service
endpointServiceMap := make(map[string][]ServiceEndpoint)
for _, endpoint := range endpoints {
endpointServiceMap[endpoint.ServiceName] = append(endpointServiceMap[endpoint.ServiceName], endpoint)
}

var endpointServices []ServiceEndpoints
for serviceName, serviceEndpoints := range endpointServiceMap {
endpointServices = append(endpointServices, ServiceEndpoints{
ServiceName: serviceName,
Endpoints:   serviceEndpoints,
})
}

// Collect all unique services
allServicesMap := make(map[string]bool)
for _, endpoint := range endpoints {
if endpoint.ServiceName != "" {
allServicesMap[endpoint.ServiceName] = true
}
if endpoint.ServerAddress != "" {
allServicesMap[endpoint.ServerAddress] = true
}
}

var allServices []string
for service := range allServicesMap {
allServices = append(allServices, service)
}
sort.Strings(allServices)

// Group database operations by service
dbServiceMap := make(map[string][]DatabaseOperation)
for _, operation := range dbOperations {
dbServiceMap[operation.ServiceName] = append(dbServiceMap[operation.ServiceName], operation)
}

var dbServices []DatabaseOperationsByService
for serviceName, operations := range dbServiceMap {
dbServices = append(dbServices, DatabaseOperationsByService{
ServiceName: serviceName,
Operations:  operations,
})
}

// Group gRPC operations by service
grpcServiceMap := make(map[string][]GRPCOperation)
for _, operation := range grpcOperations {
grpcServiceMap[operation.ServiceName] = append(grpcServiceMap[operation.ServiceName], operation)
}

var grpcServices []GRPCOperationsByService
for serviceName, operations := range grpcServiceMap {
grpcServices = append(grpcServices, GRPCOperationsByService{
ServiceName: serviceName,
Operations:  operations,
})
}

// Create template data
templateData := struct {
SystemType       string
EndpointServices []ServiceEndpoints
AllServices      []string
DBServices       []DatabaseOperationsByService
GRPCServices     []GRPCOperationsByService
}{
SystemType:       string(systemconfig.GetCurrentSystem()),
EndpointServices: endpointServices,
AllServices:      allServices,
DBServices:       dbServices,
GRPCServices:     grpcServices,
}

// Ensure output directory exists
outputDir := filepath.Dir(outputFilePath)
if err := os.MkdirAll(outputDir, 0755); err != nil {
return fmt.Errorf("failed to create output directory: %w", err)
}

// Parse template
tmpl, err := template.New("unifiedResourcesTemplate").Parse(unifiedResourcesTemplate)
if err != nil {
return fmt.Errorf("failed to parse template: %w", err)
}

// Create output file
outFile, err := os.Create(outputFilePath)
if err != nil {
return fmt.Errorf("failed to create output file: %w", err)
}
defer outFile.Close()

// Execute template
if err := tmpl.Execute(outFile, templateData); err != nil {
return fmt.Errorf("failed to execute template: %w", err)
}

return nil
}
