package javaanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// ServiceClassMethods holds the class-method pairs for a service
type ServiceClassMethods struct {
	ServiceName string
	Methods     []ClassMethodEntry
}

// Template for generating the Go file
const javaMethodsTemplate = `// Code generated by javadatagenerator.go; DO NOT EDIT.
package javaclassmethods

// ClassMethodEntry represents a class-method pair from Java analysis
type ClassMethodEntry struct {
	ClassName  string
	MethodName string
}

// ServiceClassMethods maps service names to their class-method pairs
var ServiceClassMethods = map[string][]ClassMethodEntry{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Methods }}
		{ClassName: "{{ .ClassName }}", MethodName: "{{ .MethodName }}"},
		{{- end }}
	},
{{- end }}
}

// GetClassMethodsByService returns all class-method pairs for a service
func GetClassMethodsByService(serviceName string) []ClassMethodEntry {
	if methods, exists := ServiceClassMethods[serviceName]; exists {
		return methods
	}
	return []ClassMethodEntry{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	services := make([]string, 0, len(ServiceClassMethods))
	for service := range ServiceClassMethods {
		services = append(services, service)
	}
	return services
}
`

// GenerateJavaClassMethodsFile analyzes Java services and generates a Go file
// with class-method pairs for each service
func GenerateJavaClassMethodsFile(servicesBasePath string, outputFilePath string) error {
	// List of service directories to analyze
	serviceDirs := []string{
		"ts-admin-basic-info-service", "ts-auth-service", "ts-consign-service",
		"ts-gateway-service", "ts-preserve-other-service", "ts-seat-service",
		"ts-travel2-service", "ts-admin-order-service", "ts-basic-service",
		"ts-contacts-service", "ts-inside-payment-service", "ts-preserve-service",
		"ts-security-service", "ts-travel-plan-service", "ts-admin-route-service",
		"ts-cancel-service", "ts-delivery-service", "ts-notification-service",
		"ts-price-service", "ts-station-food-service", "ts-travel-service",
		"ts-admin-travel-service", "ts-execute-service",
		"ts-order-other-service", "ts-rebook-service", "ts-station-service",
		"ts-user-service", "ts-admin-user-service", "ts-config-service",
		"ts-food-delivery-service", "ts-order-service", "ts-route-plan-service",
		"ts-train-food-service", "ts-verification-code-service", "ts-assurance-service",
		"ts-consign-price-service", "ts-food-service", "ts-payment-service",
		"ts-route-service", "ts-train-service", "ts-wait-order-service",
	}

	// Prepare full paths for analysis
	var servicePaths []string
	for _, serviceDir := range serviceDirs {
		servicePath := filepath.Join(servicesBasePath, serviceDir)
		if _, err := os.Stat(servicePath); err == nil {
			servicePaths = append(servicePaths, servicePath)
		}
	}

	// Analyze Java services
	pathResults, err := AnalyzeJavaPaths(servicePaths)
	if err != nil {
		return fmt.Errorf("failed to analyze Java services: %w", err)
	}

	// Transform path results to service class methods
	var services []ServiceClassMethods
	for _, result := range pathResults {
		serviceName := result.PathName

		services = append(services, ServiceClassMethods{
			ServiceName: serviceName,
			Methods:     result.Methods,
		})
	}

	// Create template data
	templateData := struct {
		Services []ServiceClassMethods
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("javaMethodsTemplate").Parse(javaMethodsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
