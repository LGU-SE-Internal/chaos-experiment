package javaanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/LGU-SE-Internal/chaos-experiment/internal/systemconfig"
)

// ServiceClassMethods holds the class-method pairs for a service
type ServiceClassMethods struct {
	ServiceName string
	Methods     []ClassMethodEntry
}

// Template for generating the Go file
const javaMethodsTemplate = `// Code generated by javadatagenerator.go; DO NOT EDIT.
// System: {{ .SystemType }}
package {{ .PackageName }}

// ClassMethodEntry represents a class-method pair from Java analysis
type ClassMethodEntry struct {
	ClassName  string
	MethodName string
}

// ServiceClassMethods maps service names to their class-method pairs
var ServiceClassMethods = map[string][]ClassMethodEntry{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Methods }}
		{ClassName: "{{ .ClassName }}", MethodName: "{{ .MethodName }}"},
		{{- end }}
	},
{{- end }}
}

// GetClassMethodsByService returns all class-method pairs for a service
func GetClassMethodsByService(serviceName string) []ClassMethodEntry {
	if methods, exists := ServiceClassMethods[serviceName]; exists {
		return methods
	}
	return []ClassMethodEntry{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	services := make([]string, 0, len(ServiceClassMethods))
	for service := range ServiceClassMethods {
		services = append(services, service)
	}
	return services
}
`

// TrainTicket service directories
var trainTicketServiceDirs = []string{
	"ts-admin-basic-info-service", "ts-auth-service", "ts-consign-service",
	"ts-gateway-service", "ts-preserve-other-service", "ts-seat-service",
	"ts-travel2-service", "ts-admin-order-service", "ts-basic-service",
	"ts-contacts-service", "ts-inside-payment-service", "ts-preserve-service",
	"ts-security-service", "ts-travel-plan-service", "ts-admin-route-service",
	"ts-cancel-service", "ts-delivery-service", "ts-notification-service",
	"ts-price-service", "ts-station-food-service", "ts-travel-service",
	"ts-admin-travel-service", "ts-execute-service",
	"ts-order-other-service", "ts-rebook-service", "ts-station-service",
	"ts-user-service", "ts-admin-user-service", "ts-config-service",
	"ts-food-delivery-service", "ts-order-service", "ts-route-plan-service",
	"ts-train-food-service", "ts-verification-code-service", "ts-assurance-service",
	"ts-consign-price-service", "ts-food-service", "ts-payment-service",
	"ts-route-service", "ts-train-service", "ts-wait-order-service",
}

// OtelDemo service directories - these are under src/ subdirectory
var otelDemoServiceDirs = []string{
	"ad", // AdService (Java)
}

// OtelDemo source subdirectory
const otelDemoSrcSubdir = "src"

// GetServiceDirsForSystem returns the list of service directories for the current system
func GetServiceDirsForSystem() []string {
	if systemconfig.IsTrainTicket() {
		return trainTicketServiceDirs
	}
	return otelDemoServiceDirs
}

// GetServiceBasePath returns the base path for services based on the system type
// For OtelDemo, services are under src/ subdirectory
func GetServiceBasePath(basePath string) string {
	if systemconfig.IsOtelDemo() {
		return filepath.Join(basePath, otelDemoSrcSubdir)
	}
	return basePath
}

// getPackageNameFromPath extracts the package name from the output file path
func getPackageNameFromPath(outputFilePath string) string {
	dir := filepath.Dir(outputFilePath)
	packageName := filepath.Base(dir)
	// Sanitize package name (replace - with _ for valid Go package names)
	packageName = strings.ReplaceAll(packageName, "-", "_")
	return packageName
}

// FilterClassMethods filters out unwanted class-method entries based on system-specific rules
func FilterClassMethods(entries []ClassMethodEntry) []ClassMethodEntry {
	var filtered []ClassMethodEntry
	for _, entry := range entries {
		// For OTel Demo, exclude problempattern classes
		if systemconfig.IsOtelDemo() {
			if strings.Contains(entry.ClassName, "problempattern") {
				continue
			}
		}
		filtered = append(filtered, entry)
	}
	return filtered
}

// GenerateJavaClassMethodsFile analyzes Java services and generates a Go file
// with class-method pairs for each service
func GenerateJavaClassMethodsFile(servicesBasePath string, outputFilePath string) error {
	// Get service directories based on current system
	serviceDirs := GetServiceDirsForSystem()

	// Get the correct base path (OtelDemo has src/ subdirectory)
	basePath := GetServiceBasePath(servicesBasePath)

	// Prepare full paths for analysis
	var servicePaths []string
	for _, serviceDir := range serviceDirs {
		servicePath := filepath.Join(basePath, serviceDir)
		if info, err := os.Stat(servicePath); err == nil && info.IsDir() {
			servicePaths = append(servicePaths, servicePath)
			fmt.Printf("Found service directory: %s\n", servicePath)
		} else {
			fmt.Printf("Service directory not found or not a directory: %s\n", servicePath)
		}
	}

	if len(servicePaths) == 0 {
		fmt.Printf("Warning: No service directories found in %s\n", basePath)
		fmt.Printf("Expected directories: %v\n", serviceDirs)
	}

	// Analyze Java services
	pathResults, err := AnalyzeJavaPaths(servicePaths)
	if err != nil {
		return fmt.Errorf("failed to analyze Java services: %w", err)
	}

	fmt.Printf("Analyzed %d service paths\n", len(pathResults))

	// Transform path results to service class methods
	var services []ServiceClassMethods
	for _, result := range pathResults {
		serviceName := result.PathName

		// Filter out unwanted classes
		filteredMethods := FilterClassMethods(result.Methods)

		fmt.Printf("Service %s: found %d methods (after filtering)\n", serviceName, len(filteredMethods))

		services = append(services, ServiceClassMethods{
			ServiceName: serviceName,
			Methods:     filteredMethods,
		})
	}

	// Get package name from output path
	packageName := getPackageNameFromPath(outputFilePath)

	// Create template data
	templateData := struct {
		PackageName string
		SystemType  string
		Services    []ServiceClassMethods
	}{
		PackageName: packageName,
		SystemType:  string(systemconfig.GetCurrentSystem()),
		Services:    services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("javaMethodsTemplate").Parse(javaMethodsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
